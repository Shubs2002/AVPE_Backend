"""
Imagen Service (Nano Banana Model)

This module provides image generation using Google's Imagen model.
"""

import os
from PIL import Image
from io import BytesIO
from typing import Optional
from google.genai import types
from app.connectors.genai_connector import get_genai_client


def generate_first_frame_with_imagen(
    character_image_url: str,
    frame_description: str,
    aspect_ratio: str = "9:16",
    output_dir: str = "frames"
) -> tuple[Image.Image, str]:
    """
    Generate the first frame using Imagen (nano banana model).
    Downloads the generated frame to the frames folder.
    
    Args:
        character_image_url: URL of the character image
        frame_description: Description of the scene, pose, environment
        aspect_ratio: Aspect ratio for the generated frame (default: "9:16")
        output_dir: Directory to save the frame (default: "frames")
    
    Returns:
        tuple: (PIL.Image, filepath) - Generated image and path where it was saved
    """
    import requests
    from datetime import datetime
    
    print(f"ğŸ¨ Generating first frame with Imagen (nano banana)...")
    print(f"ğŸ“ Description: {frame_description[:100]}...")
    
    # Create frames directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # Download character image if it's a URL
    character_image = None
    if character_image_url.startswith("http://") or character_image_url.startswith("https://"):
        print(f"ğŸ“¥ Downloading character image from: {character_image_url[:50]}...")
        response = requests.get(character_image_url, timeout=30)
        response.raise_for_status()
        character_image = Image.open(BytesIO(response.content))
        print(f"âœ… Character image loaded: {character_image.size}")
    else:
        raise ValueError(f"Unsupported character_image_url format: {character_image_url}")
    
    # Map aspect ratio to dimensions
    aspect_ratio_dimensions = {
        "9:16": (720, 1280),   # Vertical (Instagram/TikTok)
        "16:9": (1280, 720),   # Horizontal (YouTube)
        "1:1": (1024, 1024),   # Square (Instagram)
        "4:5": (1024, 1280),   # Vertical (Instagram)
    }
    
    target_size = aspect_ratio_dimensions.get(aspect_ratio, (720, 1280))
    
    # Build prompt for Imagen (cleaner without aspect ratio details)
    prompt = f"""Create a high-quality image.

Scene: {frame_description}

Style: Maintain the character's exact appearance from the reference image. Focus on the pose, environment, and background described. Keep the character's colors, features, and style consistent.

Requirements:
- High quality, detailed rendering
- Consistent character appearance
- Clear, vibrant colors
- Professional composition"""
    
    print(f"ğŸ¨ Generating frame with Imagen...")
    print(f"ğŸ“ Aspect ratio: {aspect_ratio}")
    
    try:
        # Get Gemini client
        client = get_genai_client()
        
        # Use Gemini 2.5 Flash Image with proper ImageConfig
        print(f"ğŸ¨ Generating image with Gemini 2.5 Flash Image...")
        
        response = client.models.generate_content(
            model="gemini-2.5-flash-image",
            contents=[prompt, character_image],
            config=types.GenerateContentConfig(
                image_config=types.ImageConfig(
                    aspect_ratio=aspect_ratio
                )
            )
        )
        
        # Extract generated image from response
        generated_image = None
        for part in response.candidates[0].content.parts:
            if part.text is not None:
                print(f"ğŸ“‹ AI Response: {part.text[:100]}...")
            elif part.inline_data is not None:
                # Found the generated image
                generated_image = Image.open(BytesIO(part.inline_data.data))
                print(f"âœ… Image generated by Gemini: {generated_image.size}")
                break
        
        if generated_image is None:
            # No image generated, use character image as fallback
            print(f"âš ï¸ No image generated in response, using character image as fallback")
            generated_image = _resize_to_aspect_ratio(character_image, aspect_ratio, target_size)
        
        # Generate filename with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"first_frame_{timestamp}.png"
        filepath = os.path.join(output_dir, filename)
        
        # Save the frame
        generated_image.save(filepath, "PNG")
        print(f"ğŸ’¾ First frame saved: {filepath}")
        print(f"ğŸ“Š Size: {generated_image.size}")
        
        return generated_image, filepath
    
    except Exception as e:
        print(f"âš ï¸ Frame generation failed: {str(e)}")
        print(f"âš ï¸ Using character image as fallback")
        
        # Fallback: Use character image with proper aspect ratio
        fallback_image = _resize_to_aspect_ratio(character_image, aspect_ratio, target_size)
        
        # Save fallback frame
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"first_frame_fallback_{timestamp}.png"
        filepath = os.path.join(output_dir, filename)
        
        fallback_image.save(filepath, "PNG")
        print(f"ğŸ’¾ Fallback frame saved: {filepath}")
        
        return fallback_image, filepath


def _resize_to_aspect_ratio(
    image: Image.Image,
    aspect_ratio: str,
    target_size: Optional[tuple] = None
) -> Image.Image:
    """
    Resize an image to match the specified aspect ratio.
    
    Args:
        image: PIL Image to resize
        aspect_ratio: Target aspect ratio (e.g., "9:16", "16:9", "1:1")
        target_size: Optional target size (width, height)
    
    Returns:
        PIL.Image: Resized image
    """
    # Parse aspect ratio
    try:
        width_ratio, height_ratio = map(int, aspect_ratio.split(':'))
    except:
        print(f"âš ï¸ Invalid aspect ratio '{aspect_ratio}', using original image")
        return image
    
    # Calculate target dimensions
    original_width, original_height = image.size
    target_aspect = width_ratio / height_ratio
    current_aspect = original_width / original_height
    
    if abs(target_aspect - current_aspect) < 0.01 and target_size is None:
        # Already correct aspect ratio
        return image
    
    # Determine new dimensions (maintain quality, crop if needed)
    if current_aspect > target_aspect:
        # Image is too wide, crop width
        new_height = original_height
        new_width = int(new_height * target_aspect)
    else:
        # Image is too tall, crop height
        new_width = original_width
        new_height = int(new_width / target_aspect)
    
    # Center crop
    left = (original_width - new_width) // 2
    top = (original_height - new_height) // 2
    right = left + new_width
    bottom = top + new_height
    
    cropped_image = image.crop((left, top, right, bottom))
    
    # Resize to target size if specified
    if target_size:
        cropped_image = cropped_image.resize(target_size, Image.Resampling.LANCZOS)
    
    print(f"âœ… Resized from {image.size} to {cropped_image.size} ({aspect_ratio})")
    
    return cropped_image


def generate_last_frame_with_imagen(
    character_image_url: str,
    first_frame_path: str,
    last_frame_description: str,
    aspect_ratio: str = "9:16",
    output_dir: str = "frames"
) -> tuple[Image.Image, str]:
    """
    Generate the last frame using Imagen with BOTH character reference and first frame reference.
    This ensures character consistency AND environment/lighting consistency.
    
    Args:
        character_image_url: URL of the character image (for character consistency)
        first_frame_path: Path to the first frame of this segment (for environment consistency)
        last_frame_description: Description of the ending pose, position, environment
        aspect_ratio: Aspect ratio for the generated frame (default: "9:16")
        output_dir: Directory to save the frame (default: "frames")
    
    Returns:
        tuple: (PIL.Image, filepath) - Generated image and path where it was saved
    """
    import requests
    from datetime import datetime
    
    print(f"ğŸ¨ Generating last frame with Imagen (nano banana)...")
    print(f"ğŸ“ Description: {last_frame_description[:100]}...")
    
    # Create frames directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # Download character image if it's a URL
    character_image = None
    if character_image_url.startswith("http://") or character_image_url.startswith("https://"):
        print(f"ğŸ“¥ Downloading character image from: {character_image_url[:50]}...")
        response = requests.get(character_image_url, timeout=30)
        response.raise_for_status()
        character_image = Image.open(BytesIO(response.content))
        print(f"âœ… Character image loaded: {character_image.size}")
    else:
        raise ValueError(f"Unsupported character_image_url format: {character_image_url}")
    
    # Load first frame
    first_frame_image = Image.open(first_frame_path)
    print(f"âœ… First frame loaded: {first_frame_image.size}")
    
    # Map aspect ratio to dimensions
    aspect_ratio_dimensions = {
        "9:16": (720, 1280),   # Vertical (Instagram/TikTok)
        "16:9": (1280, 720),   # Horizontal (YouTube)
        "1:1": (1024, 1024),   # Square (Instagram)
        "4:5": (1024, 1280),   # Vertical (Instagram)
    }
    
    target_size = aspect_ratio_dimensions.get(aspect_ratio, (720, 1280))
    
    # Build prompt for Imagen with BOTH references (cleaner without aspect ratio details)
    prompt = f"""Create a high-quality image.

Scene: {last_frame_description}

CRITICAL REQUIREMENTS:
1. Character Appearance: Use the FIRST reference image (character) to maintain exact character appearance (colors, features, style)
2. Environment & Lighting: Use the SECOND reference image (first frame) to maintain consistent environment, lighting, and background
3. Pose & Position: Follow the scene description for the character's final pose and position

The character should look EXACTLY like in the character reference image, but in the environment and lighting from the first frame reference image, with the pose described in the scene.

Style: High quality, detailed rendering with consistent character and environment.

Requirements:
- Character MUST be fully visible (whole body in frame)
- Maintain character's exact appearance from character reference
- Maintain environment/lighting from first frame reference
- Clear, vibrant colors
- Professional composition"""
    
    print(f"ğŸ¨ Generating last frame with Imagen...")
    print(f"ğŸ“ Aspect ratio: {aspect_ratio}")
    print(f"ğŸ–¼ï¸ Using character reference + first frame reference")
    
    try:
        # Get Gemini client
        client = get_genai_client()
        
        # Use Gemini 2.5 Flash Image with BOTH references and proper ImageConfig
        print(f"ğŸ¨ Generating image with Gemini 2.5 Flash Image (dual reference)...")
        
        response = client.models.generate_content(
            model="gemini-2.5-flash-image",
            contents=[prompt, character_image, first_frame_image],
            config=types.GenerateContentConfig(
                image_config=types.ImageConfig(
                    aspect_ratio=aspect_ratio
                )
            )
        )
        
        # Extract generated image from response
        generated_image = None
        for part in response.candidates[0].content.parts:
            if part.text is not None:
                print(f"ğŸ“‹ AI Response: {part.text[:100]}...")
            elif part.inline_data is not None:
                # Found the generated image
                generated_image = Image.open(BytesIO(part.inline_data.data))
                print(f"âœ… Image generated by Gemini: {generated_image.size}")
                break
        
        if generated_image is None:
            # No image generated, use first frame as fallback
            print(f"âš ï¸ No image generated in response, using first frame as fallback")
            generated_image = _resize_to_aspect_ratio(first_frame_image, aspect_ratio, target_size)
        
        # Generate filename with timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"last_frame_{timestamp}.png"
        filepath = os.path.join(output_dir, filename)
        
        # Save the frame
        generated_image.save(filepath, "PNG")
        print(f"ğŸ’¾ Last frame saved: {filepath}")
        print(f"ğŸ“Š Size: {generated_image.size}")
        
        return generated_image, filepath
    
    except Exception as e:
        print(f"âš ï¸ Last frame generation failed: {str(e)}")
        print(f"âš ï¸ Using first frame as fallback")
        
        # Fallback: Use first frame
        fallback_image = _resize_to_aspect_ratio(first_frame_image, aspect_ratio, target_size)
        
        # Save fallback frame
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"last_frame_fallback_{timestamp}.png"
        filepath = os.path.join(output_dir, filename)
        
        fallback_image.save(filepath, "PNG")
        print(f"ğŸ’¾ Fallback frame saved: {filepath}")
        
        return fallback_image, filepath


def generate_frame_from_description(
    description: str,
    aspect_ratio: str = "9:16",
    output_dir: str = "frames",
    reference_image: Optional[Image.Image] = None
) -> tuple[Image.Image, str]:
    """
    Generate a frame from text description only (no character reference).
    
    Args:
        description: Scene description
        aspect_ratio: Aspect ratio (default: "9:16")
        output_dir: Directory to save the frame
        reference_image: Optional reference image for style
    
    Returns:
        tuple: (PIL.Image, filepath)
    """
    from datetime import datetime
    
    print(f"ğŸ¨ Generating frame from description...")
    print(f"ğŸ“ Description: {description[:100]}...")
    
    # Create frames directory
    os.makedirs(output_dir, exist_ok=True)
    
    # Map aspect ratio to dimensions
    aspect_ratio_dimensions = {
        "9:16": (720, 1280),
        "16:9": (1280, 720),
        "1:1": (1024, 1024),
        "4:5": (1024, 1280),
    }
    
    target_size = aspect_ratio_dimensions.get(aspect_ratio, (720, 1280))
    
    # Build prompt
    prompt = f"""Create a high-quality image in {aspect_ratio} aspect ratio ({target_size[0]}x{target_size[1]} pixels).

{description}

Requirements:
- Aspect ratio: {aspect_ratio}
- High quality, detailed rendering
- Clear, vibrant colors
- Professional composition"""
    
    try:
        client = get_genai_client()
        
        # Prepare contents
        contents = [prompt]
        if reference_image:
            contents.append(reference_image)
        
        # Generate image with Gemini 2.5 Flash Image
        response = client.models.generate_content(
            model="gemini-2.5-flash-image",
            contents=contents
        )
        
        # Extract image
        generated_image = None
        for part in response.candidates[0].content.parts:
            if part.text is not None:
                print(f"ğŸ“‹ AI Response: {part.text[:100]}...")
            elif part.inline_data is not None:
                generated_image = Image.open(BytesIO(part.inline_data.data))
                print(f"âœ… Image generated: {generated_image.size}")
                break
        
        if generated_image is None:
            raise ValueError("No image generated in response")
        
        # Save
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"frame_{timestamp}.png"
        filepath = os.path.join(output_dir, filename)
        
        generated_image.save(filepath, "PNG")
        print(f"ğŸ’¾ Frame saved: {filepath}")
        
        return generated_image, filepath
    
    except Exception as e:
        print(f"âŒ Frame generation failed: {str(e)}")
        raise
